# Декораторы

Декораторы — это функции, которые изменяют или расширяют поведение других функций или методов, не изменяя их исходный код. Они позволяют добавлять функциональность к существующим функциям динамически. Основная цель декораторов — улучшение кода, повышение его читаемости и повторного использования.  

## Примеры основного использования декораторов

### 1. Создание простого декоратора

Декоратор — это функция, которая принимает функцию в качестве аргумента и возвращает новую функцию. Вот простой пример декоратора:  

```python
def simple_decorator(func):
    def wrapper():
        print("Декорированная функция запускается")
        func()
        print("Декорированная функция завершена")
    return wrapper

@simple_decorator
def my_function():
    print("Оригинальная функция выполняется")

my_function()
```

Вывод:

```python
Декорированная функция запускается
Оригинальная функция выполняется
Декорированная функция завершена
```

Здесь @simple_decorator — это декоратор, который применяет дополнительное поведение к функции my_function. Он вызывает функцию до и после выполнения основной функции.  

### 2. Декоратор с аргументами

Иногда функция, которую мы декорируем, принимает аргументы. Тогда декоратор должен быть настроен на передачу этих аргументов:

```python
def decorator_with_args(func):
    def wrapper(*args, **kwargs):
        print("Вызов декорированной функции с аргументами:", args, kwargs)
        return func(*args, **kwargs)
    return wrapper

@decorator_with_args
def add(a, b):
    return a + b

result = add(3, 4)
print("Результат:", result)
```

Вывод:

```python
Вызов декорированной функции с аргументами: (3, 4) {}
Результат: 7
```

Декоратор с помощью *args и **kwargs поддерживает передачу аргументов любого типа, тем самым сохраняя гибкость.

## Использование нескольких декораторов

Можно использовать несколько декораторов для одной функции. Декораторы будут применяться в порядке от ближайшего к функции до самого дальнего:
  
```python
def decorator1(func):
    def wrapper():
        print("Первый декоратор")
        func()
    return wrapper

def decorator2(func):
    def wrapper():
        print("Второй декоратор")
        func()
    return wrapper

@decorator1
@decorator2
def my_function():
    print("Оригинальная функция")

my_function()
```

Вывод:

```python
Первый декоратор
Второй декоратор
Оригинальная функция
```

## Пример: Декоратор для проверки прав доступа

Частый случай использования декораторов — это проверка прав доступа, логирование или кэширование.

```python
def check_permission(func):
    def wrapper(user):
        if user == "admin":
            return func(user)
        else:
            print("Доступ запрещен!")
    return wrapper

@check_permission
def get_admin_panel(user):
    print(f"Добро пожаловать в админ панель, {user}!")

get_admin_panel("admin")
get_admin_panel("guest")
```

Вывод:

```python
Добро пожаловать в админ панель, admin!
Доступ запрещен!
```

Этот пример показывает, как декоратор может использоваться для управления доступом к функциям.

## Резюме

Декораторы в Python — это мощный инструмент для добавления функциональности к существующим функциям и методам, не изменяя их исходный код. Основные моменты:

1. Декораторы принимают функцию в качестве аргумента и возвращают новую функцию.
2. Декораторы могут принимать любые аргументы.
3. Можно применять несколько декораторов к одной функции.
4. Декораторы могут быть реализованы как функции или классы.
5. Часто используются для логирования, проверки прав доступа, измерения времени выполнения функций и кэширования.  

Такой механизм делает код более модульным и поддерживаемым.

## Декораторы с параметрами

Декораторы с параметрами — это расширенная версия стандартных декораторов, которая позволяет передавать параметры в сам декоратор, а не только в декорируемую функцию. Это делает декораторы ещё более гибкими, позволяя им динамически адаптировать своё поведение в зависимости от переданных параметров.

### Структура декоратора с параметрами

Декоратор с параметрами — это фактически функция, которая возвращает декоратор (другую функцию). В стандартном виде декоратор выглядит как:

```python
def decorator_with_params(param1, param2):
    def actual_decorator(func):
        def wrapper(*args, **kwargs):
            # Использование параметров внутри декоратора
            print(f"Параметры декоратора: {param1}, {param2}")
            return func(*args, **kwargs)
        return wrapper
    return actual_decorator
```

* decorator_with_params(param1, param2) — функция, принимающая параметры декоратора.
* actual_decorator(func) — собственно декоратор, который оборачивает функцию.
* wrapper(*args, **kwargs) — внутренняя обёртка, которая запускает декорируемую функцию.

### Пример использования декоратора с параметрами

Рассмотрим простой пример декоратора с параметрами:

```python
def repeat(times):
    def decorator(func):
        def wrapper(*args, **kwargs):
            for _ in range(times):
                func(*args, **kwargs)
        return wrapper
    return decorator

@repeat(3)
def greet(name):
    print(f"Привет, {name}!")

greet("Иван")
```

Вывод:

```python
Привет, Иван!
Привет, Иван!
Привет, Иван!
```

Здесь декоратор @repeat(3) передаёт параметр times, который указывает, сколько раз следует вызвать функцию greet.

### Как работает декоратор с параметрами

1. Когда Python видит конструкцию @repeat(3), он сначала вызывает функцию repeat с аргументом 3.
2. Функция repeat(3) возвращает декоратор, который затем применяется к функции greet.
3. Этот декоратор вызывает функцию трижды (в соответствии с переданным параметром times).

### Пример: декоратор для логирования с уровнем важности

Предположим, мы хотим создать декоратор, который будет логировать вызов функции, и в зависимости от уровня важности (info, warning, error), выводить разные сообщения:

```python
def log(level):
    def decorator(func):
        def wrapper(*args, **kwargs):
            if level == 'info':
                print(f"[INFO] Вызов функции {func.__name__}")
            elif level == 'warning':
                print(f"[WARNING] Вызов функции {func.__name__}")
            elif level == 'error':
                print(f"[ERROR] Вызов функции {func.__name__}")
            return func(*args, **kwargs)
        return wrapper
    return decorator

@log('info')
def process_data():
    print("Обработка данных...")

@log('error')
def save_data():
    print("Ошибка при сохранении данных")

process_data()
save_data()
```

Вывод:

```python
[INFO] Вызов функции process_data
Обработка данных...
[ERROR] Вызов функции save_data
Ошибка при сохранении данных
```

Здесь декоратор @log позволяет задавать уровень важности логирования, и в зависимости от этого уровня выводятся разные сообщения.

### Декораторы с параметрами и аргументы функции

Декоратор с параметрами также может обрабатывать аргументы декорируемой функции. Например, если нужно логировать не только вызов функции, но и переданные ей аргументы:

```python
def log_args(log_result=False):
    def decorator(func):
        def wrapper(*args, **kwargs):
            print(f"Вызов функции {func.__name__} с аргументами: {args} и {kwargs}")
            result = func(*args, **kwargs)
            if log_result:
                print(f"Результат функции: {result}")
            return result
        return wrapper
    return decorator

@log_args(log_result=True)
def multiply(a, b):
    return a * b

@log_args()
def add(a, b):
    return a + b

multiply(3, 5)
add(4, 7)
```

Вывод:

```python
Вызов функции multiply с аргументами: (3, 5) и {}
Результат функции: 15
Вызов функции add с аргументами: (4, 7) и {}
```

В этом примере декоратор @log_args(log_result=True) не только логирует аргументы функции, но и выводит результат её выполнения.

### Пример: ограничение времени выполнения функции

Декоратор с параметрами можно использовать для ограничения времени выполнения функции:

```python
import time

def timeout(limit):
    def decorator(func):
        def wrapper(*args, **kwargs):
            start_time = time.time()
            result = func(*args, **kwargs)
            end_time = time.time()
            elapsed_time = end_time - start_time
            if elapsed_time > limit:
                print(f"Внимание: выполнение функции {func.__name__} заняло {elapsed_time:.2f} секунд, что превышает лимит {limit} секунд")
            else:
                print(f"Функция {func.__name__} выполнена за {elapsed_time:.2f} секунд")
            return result
        return wrapper
    return decorator

@timeout(2)
def long_running_task():
    time.sleep(3)

@timeout(1)
def quick_task():
    time.sleep(0.5)

long_running_task()
quick_task()
```

Вывод:

```python
Внимание: выполнение функции long_running_task заняло 3.00 секунд, что превышает лимит 2 секунд
Функция quick_task выполнена за 0.50 секунд
```

Этот декоратор позволяет следить за временем выполнения функции и выводить предупреждение, если оно превышает заданный лимит.

### Резюме

Декораторы с параметрами добавляют большую гибкость в программирование на Python. Основные моменты:

1. Структура: декоратор с параметрами — это функция, которая возвращает функцию-декоратор.
2. Гибкость: параметры позволяют адаптировать поведение декоратора в зависимости от требований.
3. Примеры использования: логирование, повторение вызовов, ограничение времени выполнения и другие задачи могут быть легко реализованы с помощью декораторов с параметрами.

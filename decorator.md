# Decorator

Декораторы — это функции, которые изменяют или расширяют поведение других функций или методов, не изменяя их исходный код. Они позволяют добавлять функциональность к существующим функциям динамически. Основная цель декораторов — улучшение кода, повышение его читаемости и повторного использования.  

## Примеры основного использования декораторов

### 1. Создание простого декоратора

Декоратор — это функция, которая принимает функцию в качестве аргумента и возвращает новую функцию. Вот простой пример декоратора:  

```python
def simple_decorator(func):
    def wrapper():
        print("Декорированная функция запускается")
        func()
        print("Декорированная функция завершена")
    return wrapper

@simple_decorator
def my_function():
    print("Оригинальная функция выполняется")

my_function()
```

Вывод:

```python
Декорированная функция запускается
Оригинальная функция выполняется
Декорированная функция завершена
```

Здесь @simple_decorator — это декоратор, который применяет дополнительное поведение к функции my_function. Он вызывает функцию до и после выполнения основной функции.  

### 2. Декоратор с аргументами

Иногда функция, которую мы декорируем, принимает аргументы. Тогда декоратор должен быть настроен на передачу этих аргументов:

```python
def decorator_with_args(func):
    def wrapper(*args, **kwargs):
        print("Вызов декорированной функции с аргументами:", args, kwargs)
        return func(*args, **kwargs)
    return wrapper

@decorator_with_args
def add(a, b):
    return a + b

result = add(3, 4)
print("Результат:", result)
```

Вывод:

```python
Вызов декорированной функции с аргументами: (3, 4) {}
Результат: 7
```

Декоратор с помощью *args и **kwargs поддерживает передачу аргументов любого типа, тем самым сохраняя гибкость.

## Использование нескольких декораторов

Можно использовать несколько декораторов для одной функции. Декораторы будут применяться в порядке от ближайшего к функции до самого дальнего:
  
```python
def decorator1(func):
    def wrapper():
        print("Первый декоратор")
        func()
    return wrapper

def decorator2(func):
    def wrapper():
        print("Второй декоратор")
        func()
    return wrapper

@decorator1
@decorator2
def my_function():
    print("Оригинальная функция")

my_function()
```

Вывод:

```python
Первый декоратор
Второй декоратор
Оригинальная функция
```

## Пример: Декоратор для проверки прав доступа

Частый случай использования декораторов — это проверка прав доступа, логирование или кэширование.

```python
def check_permission(func):
    def wrapper(user):
        if user == "admin":
            return func(user)
        else:
            print("Доступ запрещен!")
    return wrapper

@check_permission
def get_admin_panel(user):
    print(f"Добро пожаловать в админ панель, {user}!")

get_admin_panel("admin")
get_admin_panel("guest")
```

Вывод:

```python
Добро пожаловать в админ панель, admin!
Доступ запрещен!
```

Этот пример показывает, как декоратор может использоваться для управления доступом к функциям.

## Резюме

Декораторы в Python — это мощный инструмент для добавления функциональности к существующим функциям и методам, не изменяя их исходный код. Основные моменты:

1. Декораторы принимают функцию в качестве аргумента и возвращают новую функцию.
2. Декораторы могут принимать любые аргументы.
3. Можно применять несколько декораторов к одной функции.
4. Декораторы могут быть реализованы как функции или классы.
5. Часто используются для логирования, проверки прав доступа, измерения времени выполнения функций и кэширования.  

Такой механизм делает код более модульным и поддерживаемым.

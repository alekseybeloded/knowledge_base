# Higher-order functions

**higher-order functions** в Python — это функции, которые могут принимать другие функции в качестве аргументов или возвращать функции как результат. Этот подход является мощным инструментом функционального программирования и широко используется для создания более гибкого и чистого кода. Давайте рассмотрим, как они работают, и приведем примеры.

## Особенности и преимущества функций высшего порядка

* **Упрощать код**: можно выделить повторяющиеся операции в отдельные функции, а затем передавать их в качестве параметров.
* **Избегать дублирования**: благодаря возможности передавать функции как аргументы, можно минимизировать повторение кода.
* **Повышать читаемость и модульность кода**: высокоуровневые абстракции делают код более понятным и легче поддерживаемым.

## Примеры функций высшего порядка в Python

В Python есть несколько встроенных функций высшего порядка, таких как map(), filter(), и reduce(). Также можно создавать свои собственные функции высшего порядка.

### 1. Функция map()

Функция map() применяет переданную ей функцию ко всем элементам итерируемого объекта и возвращает итератор с результатами. Основное её предназначение — выполнить одну и ту же операцию для всех элементов итерируемого объекта, избегая необходимости использовать циклы for.

```python
map(function, iterable)
```

* **function** — функция, которая будет применяться к каждому элементу.
* **iterable** — итерируемый объект (например, список или кортеж).

Предположим, у нас есть список чисел, и мы хотим получить их квадраты.

```python
numbers = [1, 2, 3, 4, 5]
squared = map(lambda x: x ** 2, numbers)
print(list(squared))  # Вывод: [1, 4, 9, 16, 25]
```

Здесь lambda x: x ** 2 — это анонимная функция, которая возводит x в квадрат. Она передаётся в map, и map применяет эту функцию к каждому элементу списка numbers.

**Важно: map() возвращает объект типа map, который является итератором. Чтобы увидеть результат, его часто преобразуют в список с помощью list().**

Как работает map() по шагам:

* Берёт первый элемент из iterable.
* Применяет к нему function.
* Сохраняет результат.
* Переходит к следующему элементу и повторяет процесс до конца.

### 2. Функция filter()

Функция filter() отбирает элементы итерируемого объекта, для которых переданная функция возвращает True. Используется для фильтрации данных по определённому условию.

```python
filter(function, iterable)
```

* **function** — функция, которая возвращает True или False.
* **iterable** — итерируемый объект, элементы которого будут фильтроваться.

Допустим, у нас есть список чисел, и мы хотим оставить только чётные числа.

```python
numbers = [1, 2, 3, 4, 5]
evens = filter(lambda x: x % 2 == 0, numbers)
print(list(evens))  # Вывод: [2, 4]
```

Здесь функция lambda x: x % 2 == 0 возвращает True для чётных чисел и False для нечётных. filter отбирает только те элементы, для которых результат True.

**Важно: Как и map, функция filter возвращает итератор, который нужно преобразовать в список для отображения результата.**

Как работает filter() по шагам:

* Берёт первый элемент из iterable.
* Применяет к нему function.
* Если function возвращает True, элемент включается в результат; если False — пропускается.
* Переходит к следующему элементу и повторяет процесс.

### 3. Функция reduce()

Функция reduce() из модуля functools используется для последовательного применения функции к элементам итерируемого объекта (например, списка) с целью свести его к одному значению.

```python
from functools import reduce

reduce(function, iterable[, initializer])
```

* **function** — функция, принимающая два аргумента и возвращающая один результат.
* **iterable** — итерируемый объект, по которому reduce будет проходить.
* **initializer** (опционально) — начальное значение, которое используется при первой итерации.

Посчитаем произведение всех чисел в списке:

```python
from functools import reduce

numbers = [1, 2, 3, 4, 5]
product = reduce(lambda x, y: x * y, numbers)
print(product)  # Вывод: 120
```

Здесь функция lambda x, y: x * y последовательно умножает два элемента, а reduce применяет эту функцию, пока не останется одно значение — итоговое произведение всех чисел.

Как работает reduce() по шагам:

* Берёт первые два элемента из iterable и применяет к ним function, чтобы получить промежуточный результат.
* Берёт следующий элемент и применяет function к промежуточному результату и этому элементу.
* Повторяет процесс, пока не обработает все элементы, и возвращает одно итоговое значение.

**Замечание**: Если указан initializer, то он будет использован как начальное значение. В таком случае reduce начнёт работу с initializer и первым элементом iterable.

Если добавить начальное значение 10, то оно включится в процесс умножения:

```python
product_with_init = reduce(lambda x, y: x * y, numbers, 10)
print(product_with_init)  # Вывод: 1200 (10 * 1 * 2 * 3 * 4 * 5)
```

### Создание собственных функций высшего порядка

Можно написать свою функцию высшего порядка, которая принимает другую функцию как аргумент. Например, создадим функцию, которая будет применять переданную функцию к каждому элементу списка.

```python
def apply_function(data, func):
    return [func(x) for x in data]

numbers = [1, 2, 3, 4, 5]

# Возведем каждый элемент в квадрат
print(apply_function(numbers, lambda x: x ** 2))  # Вывод: [1, 4, 9, 16, 25]
```

Здесь apply_function принимает список data и функцию func, применяя эту функцию к каждому элементу списка.

## Заключение

Функции высшего порядка в Python — это мощный инструмент для работы с функциями и итерируемыми объектами, который позволяет писать чистый, модульный и эффективный код.